# 19. MQTT python Client - Paho



## 1. paho -mqtt 모듈 ( 우리가 쓸 것들만 보자)

- MQTT Python Client 모듈이며
- 설치는 커맨드창에  pip install paho-mqtt     라고 치면 깔려보림~



### 1) 구독자(Subscriber) 개발 절차

- MQTT 클라이언트 클래스 인스턴스화
- 브로커 연결
- 토픽 구독 신청
- 토픽 수신시 호출할 핸들러 등록  ( 등록하고 기다려야함! )
- 토픽 수신 대기
- 토픽 수신시 처리 - 핸들러 호출!



### 2) 발행자(Publisher) 개발 절차

- MQTT 클라이언트 클래스 인스턴스화
- 브로커 연결
- 필요시 토픽 발행(전송)



### 3) 클라이언트 클래스 인스턴스화 하기 : Client()

```python
Client(client_id="", clean_session=True, userdata =None, protocol=MQTTv311,
transport="tcp")
```

- **client_id** 
  - **브로커에 연결할 때 사용되는 고유 클라이언트 ID 문자열.**
  - 비어있거나 None인 경우, 무작위로 결정 (아두이노에선 이름 정해줘야함)
    - 이 경우 clean_session 은 True여야함
    - 하지만 우리가 기본으로 다루는건 안해도됨
- clean_session
  - 브로커와의 연결이 끊어졌을 때 브로커가 클라이언트의 정보를 지울지 여부
- **userdata**
  - 핸들러에서 사용한 사용자 정의 데이터 타입
- protocol
  - MQTT 버전을씀
- **transport**
  - 전송 프로토콜('tcp' 또는 'websocket')



```python
import paho.mqtt.client as mqtt

mqttc = mqtt.Client()   # 인스턴스 생성!
```



### 4) 연결 : connect()

```python
connect(host, port =1883, keepalive =60, bind_address="")
```

- **host**
  - **브로커의 호스트명 또는 IP주소**
- **port**
  - **브로커의 포트 번호**
- keepalive
  - 브로커와 통신 사이에 허용되는 최대 기간(초).
  - 다른 메시지가 교환되지 않으면 클라이언트가 브로커에 ping 메시지를 보낼 속도를 제어
- **bind_**address
  - 네트워크 인터페이스(랜카드)가 여러 개 인경우(우린 포함잘안됨), 바인딩할 IP 주소
- **콜백(Callback)**
  - **연결 성공 시 on_connect() 콜백 호출**



- 비동기 연결 : connect_async()  -- 잘 안씁니다.

```python
connect_async(host, port=1883, keepalive=60, bind_addres="")
```

- loop_start() 와 함께 사용하여 비 차단 방식으로 연결



- **재연결 : reconnect() :** 이전에 사용했던 접속 정보로 다시 접속 시도

- 연결 끊기 : disconnect()





## 2. 네트워크 루프(프로그래밍) - 매우 중요!(다 봐!)

- **subscriber 는 지속적으로 수신해야 함**

- **loop(timeout)**
  - 1개의 mqtt 메시지 수신/전송을 처리
  - 주로 publish할 때 직접 호출
- **loop_start()**
  - 새로운 스레드를 생성, 새로 생성된 스레드가 loop()를 호출함
    - 생성되는 스레드는 데몬스레드(메인스레드) 가 종료될떄까지 함께 종료
  - 자동으로 reconnect 실행됨
  - 멈출때는 loop_stop()
- **loop_forever()**
  - 현재 스레드로 loop()를 호출
  - 무한 루프이므로 현재 스레드로 다른 작업은 할 수 없음



### 1) 토픽 발간하기 : publish()

```python
publish(topic, payload = None, qos=0, retain =False)
```

- **topic**

  - 메시지를 게시 할 주제

- **payload**

  - **전송할 메시지**
  - **문자열!!!! ( 국제 표준임 )**

- **qos**

  - **quality of service 수준     0  ,  1 임**

- retain

  - True 설정한 경우, 해당 토픽에 대한 가장 최근의 메세지 유지

- 구독 -subscribe(topic, qos=0)  

  구독취소 - unsubscribe(topic)



### 2) 콜백 (Callback)

- 특정 이벤트(접속성공, 메시지 수신 등)가 발생했을 때 호출되는 핸들러(함수)

- 내가 호출X, 시스템이 뒤에서 호출해줌
- **on_connect(client, userdata, flag, rc)**   rc가 중요함!
  - 브로커가 연결 요청에 응답 할 때 호출
  - **client**
    - **이 콜백의 클라이언트 인스턴스**
  - **userdata**
    - **Client() 또는 user_data_set()에서 설정한 사용자 데이터**
  - **flags**
    - **브로커가 보낸 응답 플래그**
  - **rc**
    - 연결결과
    - **0 : 연결성공**
    - 1 ~ 5 : 연결 거부
    -  6 ~ 255 : 현재 사용되지 않습니다.

- **on_disconnect( client, userdata, rc )**
  - 브로커와 연결이 끊어질때 호출
  - client
    - 이 콜백의 클라이언트 인스턴스
  - userdata
    - Client() 또는 user_data_set() 에서 설정한 사용자 데이터
  - rc
    - 처리결과
    - **0 : 정상적으로 끊김**
    - 0이 아닌 값: 예외에 의해 끊어짐



### 3) 콜백 메시지 수신 처리

- **on_message(client, userdata, message)**  # client는 MQTT client임
  - subscriber 에서 메시지(토픽)가 수신됬을 때 호출
  - **client**
    - 이 콜백의 클라이언트 인스턴스
  - **userdata**
    - **Client() 또는 user_data_set() 에서 설정한 사용자 데이터**
  - **message**
    - **MQTTMessage 인스턴스!!!**
    - **속성 : topic, payload**, qos, retain