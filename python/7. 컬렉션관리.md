# 7. 컬렉션 관리

- collection을 서포트 해준다.

## 1. 컬렉션 관리 함수

- **enumerate** 
  - enumerate(시퀀스 [, start])
    - 시퀀스의 인덱스와 요소를 튜플로 묶어서 순회

```python
race = ['저그', '테란', '프로토스']
list(enumerate(race))  # 튜플에 대한 List로 정리해준다 순서를 매겨서!

[(0, '저그'), (1, '테란'), (2, '프로토스')]
```

```python
score = [88,95,70,100,99]

for no, s in enumerate(score,1): # 1부터 시작하겠다는 뜻임, no 와 1이 매칭되며 1이 없다면 0으로 시작됨
    print(str(no)+ "번 학생의 성적:", s)
    
1번 학생의 성적 :88
2번 학생의 성적 :95...
```

- **zip**

  - zip(시퀀스1,시퀀스2) ->[(값1, 값2), ...]
  - 위치기반으로 tuple 만들고 넣어준다
  - 시퀀스의 길이가 다른 경우 가장 짧은 시퀀스의 길이에 맞춤

  ```python
  dates = ['월','화','수','목','금','토','일']
  food = ['갈비탕','순댓국','칼국수','삼겹살','피자']
  
  menu = zip(dates,food)  #만약 계속 돌게하고싶으면 menu = list(zip(dates,food))로 써야됨
  
  for d,f in menu:
      print(f"{d}요일 메뉴 : {f}")   # 이렇게되면 위print나 밑print중에 하나만 실행된다 why?
  print(list(menu))   # 리스트 안으로 들어감        # 결론은 zip은 루프가 1번 돌면 사라진다 
   
  menu_dic = dict(zip(dates,food)) # 튜플이 딕셔너리로 들어가는 형태가 됨 date-key, food-value로
  print(menu_dic)
  ```

  - 문자열을 사전에 넣는 예제

  ```python
  info = """ 고길동 홍길동 둘리 도우너
  30 40 50 60
  70 60 80 50 80
  80 100 20 90 100
  80 80 80 80 80
  """        # 이런 문자열을 사전으로 만들고싶다.
  
  # 1. 라인별로 정리한다 이름과 성적을 분류
  # 2. 사람 [0] 라인에서 split으로 리스트 구성
  # 3. loop를 돌려서 성적의 list 구성한다 (2중리스트 생성)
  # 4. 뿌려진 자료를 result 내의 dict 구성으로 만들어준다.
  # 5. 성적이라는 문자열을 숫자로 바꿔준다
  
  info_lines = info.splitlines()   # 문자 쪼갤때 쓰던거 임
  studnet = info_lines[0].split() #key  splite으로 공백을 띄워줌
  print(studnet)
  								#scores =[line.split() for line in info_lines[1:]] #value 이것도 가능함
  scores = info_lines[1:]         # value
  scores = [line.split() for line in scores]# 리스트에 넣어줌 그리고, 수식의 line에서 loop돌면서 splite을 통해 각 												과목마다 list를 구성해준다/바깥의 []에의해2중 리스트가 구성됨
  print(scores)                               # 안쪽 리스트 들이 각 학생별의 data가 된다. 2중 리스트를 나타낸다.
  
  result = dict(zip(studnet,scores))        # 여기서 scores의 이중 리스트가 이제 단일 리스트로 나오며 개인별로 과목의 점수를 알려준다
  print(result)
  
  
  
  #dic ={
  #    '고길동' :[]
  #}
  
  #for c in  :
  #    dic['고길동'].append(c) 으로 append 방법으로 채워나갈 수 있음
  ```

  

- any(), all()
  - any(시퀀스)
    - 시퀀스에 하나라도 True가 있으면 True 리턴
  - all(시퀀스)
    - 시퀀스의 모든 요소가 True이면 True 리턴

```python
adult = [True,False,True,False]

print(any(adult))
print(all(adult))
```



- filter
  - filter(판정함수, 시퀀스) -> 시퀀스
    - 시퀀스의 각 요소를 판정함수에 전달하여 True를 리턴하는 요소로만 구성된 새로운 시퀀스 리턴
    - 즉 True 인것만 return 하겠다 false무시하고 진행

```python
def flunk(s):
return s < 60

score = [ 45, 89, 72, 53, 94 ]
for s in filter(flunk, score):
    print(s)# s<60 의 expression을 쓰는 flunk 함수를 정의할 수도 있다. 하지만 겉으로 간단한 함수인데 굳이 이렇게 공들여 써야겠는가?
    
    
for s in filter(lambda s: s<60  ,score):                 ## 여기 람다 함수를 써보자 Case 1. #값만 보여줌
    print(s)                        #  s<60 이면 return 해라는 뜻이다 (return 생략됨)
                                    #본체 유지되고새로운 sequence가 return 된다
# 문장(statement)
# 표현식(expression)  => 값이 나오는 식

## 1줄짜리 문장으로 표현할때는 Case 2.
score2 = list(filter(lambda a: a<60,score)) # 리스트로 표현이된다.
print(score2)

# comprehension 바로 함수 쓰는거 으로 구성해보자  얜 파이썬 고유라 잘 안씀 딴데선 Case 3.  # 리스트로 표현이 된다.
score2 = [ n for n in score if n<60 ]
print(score2)

```

